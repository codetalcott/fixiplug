// Create a fake response
      const fakeResponse = {
        ok: true,
        status: 202, // Accepted
        text: JSON.stringify({ queued: true, message: 'Request queued for when online' }),
        headers: new Headers({ 'Content-Type': 'application/json' }),
        url: context.config.url,
        json: () => ({ queued: true, message: 'Request queued for when online' }),
        blob: () => Promise.reject(new Error('Offline mode - cannot get blob')),
        arrayBuffer: () => Promise.reject(new Error('Offline mode - cannot get arrayBuffer')),
        formData: () => Promise.reject(new Error('Offline mode - cannot get formData'))
      } as FxResponse;
      
      // Stop processing and return offline response
      context.response = fakeResponse;
      throw new Error('Offline mode - request queued for later');
    }
    
    return context.config;
  },
  
  // Fallback for offline errors
  fallbacks: {
    [PluginHook.BEFORE_REQUEST]: (context, error) => {
      if (error.message.includes('Offline mode')) {
        return context.config;
      }
      throw error;
    }
  },
  
  // Handle going offline
  handleOffline() {
    this.isOnline = false;
  },
  
  // Handle coming back online
  handleOnline() {
    this.isOnline = true;
    
    // Sync queued requests if enabled
    if (this.config.syncOnReconnect) {
      this.syncQueuedRequests();
    }
  },
  
  // Queue a request for when online
  queueRequest(config: any) {
    // Clone the config and remove properties that won't serialize
    const clonedConfig = { ...config };
    
    // Handle FormData (can't be serialized)
    if (clonedConfig.body instanceof FormData) {
      const formData: Record<string, any> = {};
      for (const [key, value] of clonedConfig.body.entries()) {
        formData[key] = value;
      }
      clonedConfig._formData = formData;
      delete clonedConfig.body;
    }
    
    // Remove functions and other non-serializable properties
    delete clonedConfig.signal;
    delete clonedConfig.controller;
    
    // Add to queue
    this.queue.push({
      config: clonedConfig,
      timestamp: Date.now()
    });
    
    // Save queue to storage
    this.saveQueue();
  },
  
  // Process all queued requests
  async syncQueuedRequests() {
    if (!this.isOnline || this.queue.length === 0) {
      return;
    }
    
    // Get Fixi instance
    const fixi = (this._context?.fixi || null) as Fixi | null;
    if (!fixi) {
      return;
    }
    
    const queueCopy = [...this.queue];
    this.queue = [];
    this.saveQueue();
    
    // Process each queued request
    for (const item of queueCopy) {
      try {
        const config = { ...item.config };
        
        // Recreate FormData if needed
        if (config._formData) {
          const formData = new FormData();
          for (const [key, value] of Object.entries(config._formData)) {
            formData.append(key, value);
          }
          config.body = formData;
          delete config._formData;
        }
        
        // Skip offline handling for this request
        config.offline = false;
        
        // Execute the request
        await fixi.fetch(config);
      } catch (error) {
        // If still failed, add back to queue
        this.queueRequest(item.config);
      }
    }
  },
  
  // Save queue to localStorage
  saveQueue() {
    if (typeof window !== 'undefined' && window.localStorage) {
      try {
        window.localStorage.setItem(this.config.queueKey, JSON.stringify(this.queue));
      } catch (e) {
        console.warn('Failed to save offline queue to localStorage:', e);
      }
    }
  },
  
  // Load queue from localStorage
  loadQueue() {
    if (typeof window !== 'undefined' && window.localStorage) {
      try {
        const saved = window.localStorage.getItem(this.config.queueKey);
        if (saved) {
          this.queue = JSON.parse(saved);
        }
      } catch (e) {
        console.warn('Failed to load offline queue from localStorage:', e);
        this.queue = [];
      }
    }
  },
  
  // Configure the plugin
  configure(options: Partial<OfflineConfig>) {
    this.config = { ...this.config, ...options };
    return this;
  },
  
  // Manually sync queued requests
  sync() {
    return this.syncQueuedRequests();
  },
  
  // Get the current queue
  getQueue() {
    return [...this.queue];
  },
  
  // Clear the queue
  clearQueue() {
    this.queue = [];
    this.saveQueue();
  }
});

/* ============================
   Metrics and Logging Plugin
============================ */

/**
 * Log level type
 */
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

/**
 * A plugin for comprehensive logging and metrics
 */
export const LoggingPlugin = createPlugin({
  name: 'logging',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 100, // Highest priority to capture everything
  description: 'Provides comprehensive logging and metrics',
  author: 'Team Fixi',
  
  // Logging configuration
  config: {
    level: 'info' as LogLevel,
    includeTimestamps: true,
    logToConsole: true,
    captureMetrics: true,
    logNetwork: true,
    logErrors: true
  },
  
  // Metrics storage
  metrics: {
    totalRequests: 0,
    successRequests: 0,
    errorRequests: 0,
    totalDuration: 0,
    requestsByEndpoint: new Map<string, {
      count: number,
      success: number,
      error: number,
      totalDuration: number
    }>()
  },
  
  // Request timing data
  requestTimes: new Map<string, number>(),
  
  // Initialize the plugin
  onInitialize(context) {
    this.resetMetrics();
  },
  
  // Reset all metrics
  resetMetrics() {
    this.metrics = {
      totalRequests: 0,
      successRequests: 0,
      errorRequests: 0,
      totalDuration: 0,
      requestsByEndpoint: new Map()
    };
    this.requestTimes.clear();
  },
  
  // Log request start
  beforeRequest(context) {
    if (this.config.logNetwork) {
      this.log('info', `Request: ${context.config.method || 'GET'} ${context.config.url}`);
      this.log('debug', 'Request config:', context.config);
    }
    
    if (this.config.captureMetrics) {
      const requestId = this.getRequestId(context.config);
      this.requestTimes.set(requestId, performance.now());
      this.metrics.totalRequests++;
      
      // Track by endpoint
      const endpoint = this.getEndpointName(context.config.url);
      const endpointMetrics = this.metrics.requestsByEndpoint.get(endpoint) || {
        count: 0,
        success: 0,
        error: 0,
        totalDuration: 0
      };
      
      endpointMetrics.count++;
      this.metrics.requestsByEndpoint.set(endpoint, endpointMetrics);
    }
    
    return context.config;
  },
  
  // Log response
  afterResponse(context) {
    if (this.config.captureMetrics) {
      const requestId = this.getRequestId(context.config);
      const startTime = this.requestTimes.get(requestId);
      
      if (startTime) {
        const duration = performance.now() - startTime;
        this.requestTimes.delete(requestId);
        
        this.metrics.totalDuration += duration;
        
        if (context.response?.ok) {
          this.metrics.successRequests++;
        } else {
          this.metrics.errorRequests++;
        }
        
        // Update endpoint metrics
        const endpoint = this.getEndpointName(context.config.url);
        const endpointMetrics = this.metrics.requestsByEndpoint.get(endpoint)!;
        
        endpointMetrics.totalDuration += duration;
        if (context.response?.ok) {
          endpointMetrics.success++;
        } else {
          endpointMetrics.error++;
        }
      }
    }
    
    if (this.config.logNetwork) {
      const status = context.response?.status || 0;
      const method = context.config.method || 'GET';
      
      if (context.response?.ok) {
        this.log('info', `Response: ${method} ${context.config.url} - ${status}`);
        this.log('debug', 'Response data:', context.response);
      } else if (this.config.logErrors) {
        this.log('error', `Error: ${method} ${context.config.url} - ${status}`);
        this.log('debug', 'Error response:', context.response);
      }
    }
    
    return context.response!;
  },
  
  // Log errors
  onError(context) {
    if (this.config.logErrors) {
      this.log('error', `Request failed: ${context.config.method || 'GET'} ${context.config.url}`);
      this.log('error', context.error);
    }
    
    if (this.config.captureMetrics) {
      const requestId = this.getRequestId(context.config);
      this.requestTimes.delete(requestId);
      
      this.metrics.errorRequests++;
      
      // Update endpoint metrics
      const endpoint = this.getEndpointName(context.config.url);
      const endpointMetrics = this.metrics.requestsByEndpoint.get(endpoint);
      
      if (endpointMetrics) {
        endpointMetrics.error++;
      }
    }
  },
  
  // Log to console and capture logs
  log(level: LogLevel, message: string, ...args: any[]) {
    const logLevels = { debug: 0, info: 1, warn: 2, error: 3 };
    if (logLevels[level] < logLevels[this.config.level]) {
      return;
    }
    
    const timestamp = this.config.includeTimestamps ? `[${new Date().toISOString()}] ` : '';
    const formattedMessage = `${timestamp}[Fixi] ${message}`;
    
    if (this.config.logToConsole) {
      console[level](formattedMessage, ...args);
    }
  },
  
  // Generate a unique ID for each request
  getRequestId(config: any): string {
    return `${config.method || 'GET'}-${config.url}-${Date.now()}`;
  },
  
  // Extract endpoint name from URL for grouping
  getEndpointName(url: string): string {
    try {
      const parsedUrl = new URL(url, window.location.origin);
      return parsedUrl.pathname.replace(/\/(\d+)($|\/)/g, '/:id$2');
    } catch (e) {
      return url.split('?')[0].split('#')[0];
    }
  },
  
  // Get metrics for analysis
  getMetrics() {
    return {
      ...this.metrics,
      averageDuration: this.metrics.totalRequests > 0
        ? this.metrics.totalDuration / this.metrics.totalRequests
        : 0,
      successRate: this.metrics.totalRequests > 0
        ? this.metrics.successRequests / this.metrics.totalRequests
        : 0,
      requestsByEndpoint: Object.fromEntries(this.metrics.requestsByEndpoint)
    };
  },
  
  // Configure the plugin
  configure(options: Partial<typeof this.config>) {
    this.config = { ...this.config, ...options };
    return this;
  }
});

/* ============================
   Progress Indicator Plugin
============================ */

/**
 * A plugin that shows loading indicators for requests
 */
export const ProgressPlugin = createPlugin({
  name: 'progress',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 90,
  description: 'Shows loading indicators for requests',
  author: 'Team Fixi',
  
  // Configuration options
  config: {
    defaultSelector: 'body',
    defaultClass: 'loading',
    showGlobalIndicator: true,
    targetIndicatorClass: 'loading-target',
    minDuration: 300, // Min ms to show the indicator
    indicatorDelay: 200, // Delay before showing to prevent flashing
    counterThreshold: 0  // Threshold to show the counter (0 = always show)
  },
  
  // Request counter
  counter: 0,
  
  // Timeout IDs
  timeouts: new Map<string, any>(),
  showTimeouts: new Map<string, any>(),
  
  // Active target elements
  activeTargets: new Set<Element>(),
  
  // Last indicator toggle time
  lastToggleTime: 0,
  
  // Condition: Skip if tagged to ignore progress
  conditions: {
    [PluginHook.BEFORE_REQUEST]: (context: RequestPluginContext) => {
      return context.config.showProgress !== false;
    }
  },
  
  // Initialize the plugin
  onInitialize() {
    this.counter = 0;
    this.timeouts.clear();
    this.showTimeouts.clear();
    this.activeTargets.clear();
    this.lastToggleTime = 0;
  },
  
  // Cleanup on unregister
  onDestroy() {
    // Clear all timeouts
    this.timeouts.forEach(id => clearTimeout(id));
    this.showTimeouts.forEach(id => clearTimeout(id));
    
    // Remove all loading indicators
    this.hideGlobalIndicator();
    this.activeTargets.forEach(el => this.hideTargetIndicator(el));
  },
  
  // Before request, show loading indicator
  beforeRequest(context) {
    const requestId = this.getRequestId(context.config);
    
    // Increment counter
    this.incrementCounter();
    
    // Show global indicator if enabled
    if (this.config.showGlobalIndicator) {
      // Only show after delay to prevent flashing for fast requests
      const timeoutId = setTimeout(() => {
        this.showGlobalIndicator();
        this.showTimeouts.delete(requestId);
      }, this.config.indicatorDelay);
      
      this.showTimeouts.set(requestId, timeoutId);
    }
    
    // Show target indicator if target specified
    if (context.config.target) {
      const target = this.resolveTarget(context.config.target);
      if (target) {
        // Add to active targets
        this.activeTargets.add(target);
        
        // Only show after delay
        const timeoutId = setTimeout(() => {
          this.showTargetIndicator(target);
          this.showTimeouts.delete(`${requestId}-target`);
        }, this.config.indicatorDelay);
        
        this.showTimeouts.set(`${requestId}-target`, timeoutId);
      }
    }
    
    return context.config;
  },
  
  // After response, hide loading indicator
  afterResponse(context) {
    const requestId = this.getRequestId(context.config);
    
    // Clear show timeout if it hasn't fired yet
    if (this.showTimeouts.has(requestId)) {
      clearTimeout(this.showTimeouts.get(requestId));
      this.showTimeouts.delete(requestId);
    }
    
    if (this.showTimeouts.has(`${requestId}-target`)) {
      clearTimeout(this.showTimeouts.get(`${requestId}-target`));
      this.showTimeouts.delete(`${requestId}-target`);
    }
    
    // Decrement counter
    this.decrementCounter();
    
    // Handle target indicator
    if (context.config.target) {
      const target = this.resolveTarget(context.config.target);
      if (target) {
        // Ensure minimum visible duration
        const minTimeRemaining = this.getMinTimeRemaining();
        
        if (minTimeRemaining > 0) {
          const timeoutId = setTimeout(() => {
            this.hideTargetIndicator(target);
            this.timeouts.delete(`${requestId}-target`);
          }, minTimeRemaining);
          
          this.timeouts.set(`${requestId}-target`, timeoutId);
        } else {
          this.hideTargetIndicator(target);
        }
      }
    }
    
    return context.response!;
  },
  
  // Handle errors
  onError(context) {
    // Use same cleanup as afterResponse
    const requestId = this.getRequestId(context.config);
    
    // Clear show timeout if it hasn't fired yet
    if (this.showTimeouts.has(requestId)) {
      clearTimeout(this.showTimeouts.get(requestId));
      this.showTimeouts.delete(requestId);
    }
    
    if (this.showTimeouts.has(`${requestId}-target`)) {
      clearTimeout(this.showTimeouts.get(`${requestId}-target`));
      this.showTimeouts.delete(`${requestId}-target`);
    }
    
    // Decrement counter
    this.decrementCounter();
    
    // Handle target indicator
    if (context.config.target) {
      const target = this.resolveTarget(context.config.target);
      if (target) {
        this.hideTargetIndicator(target);
      }
    }
  },
  
  // Increment the request counter
  incrementCounter() {
    this.counter++;
    this.updateCounterDisplay();
  },
  
  // Decrement the request counter
  decrementCounter() {
    this.counter = Math.max(0, this.counter - 1);
    
    if (this.counter === 0) {
      // Hide global indicator after ensuring minimum duration
      const minTimeRemaining = this.getMinTimeRemaining();
      
      if (minTimeRemaining > 0) {
        const timeoutId = setTimeout(() => {
          this.hideGlobalIndicator();
          this.timeouts.delete('global');
        }, minTimeRemaining);
        
        this.timeouts.set('global', timeoutId);
      } else {
        this.hideGlobalIndicator();
      }
    } else {
      this.updateCounterDisplay();
    }
  },
  
  // Show the global loading indicator
  showGlobalIndicator() {
    if (typeof document === 'undefined') return;
    
    const el = document.querySelector(this.config.defaultSelector);
    if (el) {
      el.classList.add(this.config.defaultClass);
      this.lastToggleTime = Date.now();
    }
  },
  
  // Hide the global loading indicator
  hideGlobalIndicator() {
    if (typeof document === 'undefined') return;
    
    const el = document.querySelector(this.config.defaultSelector);
    if (el) {
      el.classList.remove(this.config.defaultClass);
    }
    
    // Clear counter element
    const counter = document.querySelector('.fixi-request-counter');
    if (counter) {
      counter.textContent = '';
    }
  },
  
  // Show loading indicator on a specific target
  showTargetIndicator(target: Element) {
    target.classList.add(this.config.targetIndicatorClass);
  },
  
  // Hide loading indicator on a specific target
  hideTargetIndicator(target: Element) {
    target.classList.remove(this.config.targetIndicatorClass);
    this.activeTargets.delete(target);
  },
  
  // Update the counter display
  updateCounterDisplay() {
    if (typeof document === 'undefined' || this.counter <= this.config.counterThreshold) return;
    
    // Find or create counter element
    let counter = document.querySelector('.fixi-request-counter');
    if (!counter) {
      counter = document.createElement('div');
      counter.className = 'fixi-request-counter';
      counter.style.position = 'fixed';
      counter.style.top = '10px';
      counter.style.right = '10px';
      counter.style.background = 'rgba(0,0,0,0.7)';
      counter.style.color = 'white';
      counter.style.padding = '2px 6px';
      counter.style.borderRadius = '4px';
      counter.style.fontSize = '12px';
      counter.style.zIndex = '9999';
      document.body.appendChild(counter);
    }
    
    counter.textContent = `${this.counter}`;
  },
  
  // Get minimum time remaining to show the indicator
  getMinTimeRemaining(): number {
    const elapsed = Date.now() - this.lastToggleTime;
    return Math.max(0, this.config.minDuration - elapsed);
  },
  
  // Generate a unique ID for each request
  getRequestId(config: any): string {
    return `${config.method || 'GET'}-${config.url}-${Date.now()}`;
  },
  
  // Resolve target element from string or Element
  resolveTarget(target: string | Element): Element | null {
    if (typeof document === 'undefined') return null;
    
    if (typeof target === 'string') {
      return document.querySelector(target);
    }
    
    return target;
  },
  
  // Configure the plugin
  configure(options: Partial<typeof this.config>) {
    this.config = { ...this.config, ...options };
    return this;
  }
});

/* ============================
   Usage Examples
============================ */

/**
 * Example of creating and configuring a Fixi instance with plugins
 */
export function createFixiWithPlugins() {
  // Import the core Fixi library and plugin system
  // import Fixi from './fixi.js';         // ESM runtime requires .js extension
  // import { createPluginSystem } from './plugin.js';
  
  // Create a standard Fixi instance
  const fixi = new Fixi({
    baseUrl: 'https://api.example.com'
  });
  
  // Enhance Fixi with plugin capabilities
  const fx = createPluginSystem(fixi, {
    // Register plugins immediately
    plugins: [
      // Basic setup with common plugins
      CsrfPlugin,
      LoggingPlugin,
      ProgressPlugin,
      
      // Configure error handler with automatic retry
      ErrorHandlerPlugin.configureRetry({
        enabled: true,
        maxRetries: 3,
        retryStatuses: [408, 429, 500, 502, 503, 504]
      }),
      
      // Configure cache with LRU strategy
      CachePlugin.configure({
        strategy: CacheStrategy.LRU,
        maxSize: 50,
        ttl: 10 * 60 * 1000 // 10 minutes
      })
    ],
    
    // Register lazy-loaded plugins
    lazyPlugins: [
      {
        name: 'analytics',
        load: async () => AnalyticsPlugin
      },
      {
        name: 'offline',
        load: async () => OfflinePlugin
      }
    ]
  });
  
  // Load lazy plugins when needed
  async function loadAnalytics() {
    await fx.loadPlugin('analytics');
    console.log('Analytics plugin loaded');
  }
  
  // Use the enhanced Fixi instance
  async function example() {
    try {
      // Make a request
      const response = await fx.get('/users');
      
      // See plugin health
      const health = fx.getPluginHealth();
      console.log('Plugin health:', health);
      
      // Get performance metrics
      const metrics = fx.getPerformanceMetrics();
      console.log('Performance metrics:', metrics);
    } catch (error) {
      console.error('Request failed:', error);
    }
  }
  
  return fx;
}
/**
 * Fixi Plugin System Examples
 * 
 * This file contains example implementations of common plugins for the
 * Improved Fixi Plugin System, demonstrating best practices and patterns.
 */

import { createPlugin, FixiPlugs, PluginHook, RequestPluginContext, DomPluginContext } from './fixi-plugins';
import { Fixi, FxResponse, HttpError } from './fixi';

/* ============================
   Analytics Plugin
============================ */

/**
 * A plugin for tracking request performance metrics
 */
export const AnalyticsPlugin = createPlugin({
  name: 'analytics',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 100, // High priority to ensure it runs first for accurate timing
  description: 'Tracks AJAX request performance metrics',
  author: 'Team Fixi',
  
  // Track metrics for different request types
  metrics: {
    requests: {
      total: 0,
      success: 0,
      failed: 0,
      averageDuration: 0,
      totalDuration: 0
    },
    // Separate metrics by HTTP method
    byMethod: new Map<string, {
      count: number,
      totalDuration: number,
      averageDuration: number
    }>(),
    // Track timing by URL pattern
    byUrlPattern: new Map<string, {
      count: number,
      totalDuration: number,
      averageDuration: number
    }>()
  },
  
  // Store request start times
  requestTimes: new Map<string, number>(),
  
  // Initialize metrics
  onInitialize(context) {
    this.metrics.requests.total = 0;
    this.metrics.requests.success = 0;
    this.metrics.requests.failed = 0;
    this.metrics.requests.averageDuration = 0;
    this.metrics.requests.totalDuration = 0;
    this.metrics.byMethod.clear();
    this.metrics.byUrlPattern.clear();
    this.requestTimes.clear();
  },
  
  // Clean up when unregistered
  onDestroy() {
    this.requestTimes.clear();
  },
  
  // Track the start of each request
  beforeRequest(context) {
    const requestId = this.generateRequestId(context.config);
    this.requestTimes.set(requestId, performance.now());
    return context.config;
  },
  
  // Track request completion time
  afterResponse(context) {
    const requestId = this.generateRequestId(context.config);
    const startTime = this.requestTimes.get(requestId);
    
    if (startTime) {
      const duration = performance.now() - startTime;
      this.requestTimes.delete(requestId); // Clean up to prevent memory leaks
      
      // Update overall metrics
      this.metrics.requests.total++;
      this.metrics.requests.success++;
      this.metrics.requests.totalDuration += duration;
      this.metrics.requests.averageDuration = this.metrics.requests.totalDuration / this.metrics.requests.success;
      
      // Update metrics by method
      const method = context.config.method || 'GET';
      const methodMetrics = this.metrics.byMethod.get(method) || { count: 0, totalDuration: 0, averageDuration: 0 };
      methodMetrics.count++;
      methodMetrics.totalDuration += duration;
      methodMetrics.averageDuration = methodMetrics.totalDuration / methodMetrics.count;
      this.metrics.byMethod.set(method, methodMetrics);
      
      // Update metrics by URL pattern
      const urlPattern = this.getUrlPattern(context.config.url);
      const urlMetrics = this.metrics.byUrlPattern.get(urlPattern) || { count: 0, totalDuration: 0, averageDuration: 0 };
      urlMetrics.count++;
      urlMetrics.totalDuration += duration;
      urlMetrics.averageDuration = urlMetrics.totalDuration / urlMetrics.count;
      this.metrics.byUrlPattern.set(urlPattern, urlMetrics);
    }
    
    return context.response!;
  },
  
  // Track failed requests
  onError(context) {
    const requestId = this.generateRequestId(context.config);
    const startTime = this.requestTimes.get(requestId);
    
    if (startTime) {
      const duration = performance.now() - startTime;
      this.requestTimes.delete(requestId); // Clean up to prevent memory leaks
      
      // Update overall metrics
      this.metrics.requests.total++;
      this.metrics.requests.failed++;
    }
  },
  
  // Generate a unique ID for each request for tracking
  generateRequestId(config: any): string {
    return `${config.method || 'GET'}-${config.url}-${Date.now()}`;
  },
  
  // Extract a pattern from a URL for grouping similar requests
  getUrlPattern(url: string): string {
    try {
      // Remove query parameters and hash
      let pattern = url.split('?')[0].split('#')[0];
      
      // Replace numeric IDs with placeholders
      // e.g. /users/123 -> /users/:id
      pattern = pattern.replace(/\/(\d+)(?:\/|$)/g, '/:id$1');
      
      return pattern;
    } catch (e) {
      return url;
    }
  },
  
  // Get metrics for analysis
  getMetrics() {
    return {
      ...this.metrics,
      byMethod: Object.fromEntries(this.metrics.byMethod),
      byUrlPattern: Object.fromEntries(this.metrics.byUrlPattern)
    };
  },
  
  // Get average duration for all requests
  getAverageDuration(): number {
    return this.metrics.requests.averageDuration;
  },
  
  // Reset all metrics
  resetMetrics() {
    this.onInitialize({ fixi: {} as Fixi });
  }
});

/* ============================
   Cache Plugin
============================ */

/**
 * Cache expiration strategies
 */
export enum CacheStrategy {
  // Time-based expiration
  TTL = 'ttl',
  // LRU (Least Recently Used)
  LRU = 'lru', 
  // Never expires unless manually cleared
  PERMANENT = 'permanent'
}

/**
 * Cache entry with metadata
 */
interface CacheEntry {
  response: FxResponse;
  expires: number;
  lastAccessed: number;
  hits: number;
}

/**
 * A plugin for client-side caching of responses
 */
export const CachePlugin = createPlugin({
  name: 'cache',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 90, // High priority to check cache before request is made
  description: 'Implements client-side caching for GET requests',
  author: 'Team Fixi',
  
  // Default TTL of 5 minutes
  ttl: 5 * 60 * 1000,
  
  // Max cache size (entries) for LRU
  maxSize: 100,
  
  // Default strategy
  strategy: CacheStrategy.TTL,
  
  // Only cache GET requests by default
  cacheableMethods: ['GET'],
  
  // Skip requests with certain headers
  skipWithHeaders: ['Cache-Control: no-cache', 'Cache-Control: no-store'],
  
  // Cache storage
  cache: new Map<string, CacheEntry>(),
  
  // Condition to only run for cacheable requests
  conditions: {
    [PluginHook.BEFORE_REQUEST]: (context: RequestPluginContext) => {
      const method = context.config.method || 'GET';
      return (this as any).isCacheable(context.config);
    }
  },
  
  // Initialize plugin with options
  onInitialize(context) {
    this.cache.clear();
    
    // Check for localStorage cache persistence if available
    if (typeof window !== 'undefined' && window.localStorage) {
      try {
        const savedCache = window.localStorage.getItem('fixi_cache');
        if (savedCache) {
          const parsed = JSON.parse(savedCache);
          
          // Convert serialized cache back to Map with proper expiration checks
          for (const [key, entry] of Object.entries(parsed)) {
            if (!this.isExpired(entry as CacheEntry)) {
              this.cache.set(key, entry as CacheEntry);
            }
          }
        }
      } catch (e) {
        console.warn('Failed to load cached responses from localStorage:', e);
      }
    }
  },
  
  // Clean up on unregister
  onDestroy() {
    // Save cache to localStorage if available
    if (typeof window !== 'undefined' && window.localStorage) {
      try {
        // Only save unexpired entries
        const toSave: Record<string, CacheEntry> = {};
        for (const [key, entry] of this.cache.entries()) {
          if (!this.isExpired(entry)) {
            toSave[key] = entry;
          }
        }
        window.localStorage.setItem('fixi_cache', JSON.stringify(toSave));
      } catch (e) {
        console.warn('Failed to save cached responses to localStorage:', e);
      }
    }
    
    this.cache.clear();
  },
  
  // Check cache before making request
  beforeRequest(context) {
    const cacheKey = this.getCacheKey(context.config);
    const cachedEntry = this.cache.get(cacheKey);
    
    if (cachedEntry && !this.isExpired(cachedEntry)) {
      // Update cache hit metrics
      cachedEntry.hits++;
      cachedEntry.lastAccessed = Date.now();
      this.cache.set(cacheKey, cachedEntry);
      
      // Store cached response in context for later use
      context.cachedResponse = cachedEntry.response;
    }
    
    return context.config;
  },
  
  // Use cached response or cache new response
  afterResponse(context) {
    // Return cached response if available
    if (context.cachedResponse) {
      return context.cachedResponse;
    }
    
    // Cache new response if request is cacheable
    if (this.isCacheable(context.config) && context.response?.ok) {
      const cacheKey = this.getCacheKey(context.config);
      
      // Calculate expiration time based on strategy
      let expires = Infinity;
      if (this.strategy === CacheStrategy.TTL) {
        expires = Date.now() + this.ttl;
      }
      
      const cacheEntry: CacheEntry = {
        response: context.response!,
        expires,
        lastAccessed: Date.now(),
        hits: 1
      };
      
      // Add to cache
      this.cache.set(cacheKey, cacheEntry);
      
      // Enforce max size for LRU strategy
      if (this.strategy === CacheStrategy.LRU && this.cache.size > this.maxSize) {
        this.evictLeastRecentlyUsed();
      }
    }
    
    return context.response!;
  },
  
  // Generate a cache key for a request
  getCacheKey(config: any): string {
    const url = config.url;
    const method = config.method || 'GET';
    
    // For GET requests with body (query params), include them in the key
    let bodyKey = '';
    if (config.body && method === 'GET') {
      if (typeof config.body === 'string') {
        bodyKey = config.body;
      } else if (config.body instanceof FormData) {
        bodyKey = new URLSearchParams(config.body as any).toString();
      } else if (typeof config.body === 'object') {
        bodyKey = JSON.stringify(config.body);
      }
    }
    
    return `${method}-${url}${bodyKey ? '-' + bodyKey : ''}`;
  },
  
  // Check if a cache entry has expired
  isExpired(entry: CacheEntry): boolean {
    if (this.strategy === CacheStrategy.PERMANENT) {
      return false;
    }
    
    if (this.strategy === CacheStrategy.TTL) {
      return Date.now() > entry.expires;
    }
    
    // For LRU, entries don't expire by time
    return false;
  },
  
  // Remove the least recently used entry
  evictLeastRecentlyUsed() {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessed < oldestTime) {
        oldestTime = entry.lastAccessed;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  },
  
  // Determine if a request should be cached
  isCacheable(config: any): boolean {
    const method = config.method || 'GET';
    
    // Check if method is cacheable
    if (!this.cacheableMethods.includes(method)) {
      return false;
    }
    
    // Check for no-cache headers
    if (config.headers) {
      for (const skipHeader of this.skipWithHeaders) {
        const [name, value] = skipHeader.split(': ');
        
        if (config.headers[name] === value) {
          return false;
        }
      }
    }
    
    return true;
  },
  
  // Clear all cached responses
  clearCache() {
    this.cache.clear();
  },
  
  // Remove a specific URL from cache
  removeFromCache(url: string) {
    for (const key of this.cache.keys()) {
      if (key.includes(url)) {
        this.cache.delete(key);
      }
    }
  },
  
  // Configure plugin options
  configure(options: {
    ttl?: number;
    maxSize?: number;
    strategy?: CacheStrategy;
    cacheableMethods?: string[];
  }) {
    if (options.ttl !== undefined) {
      this.ttl = options.ttl;
    }
    
    if (options.maxSize !== undefined) {
      this.maxSize = options.maxSize;
    }
    
    if (options.strategy !== undefined) {
      this.strategy = options.strategy;
    }
    
    if (options.cacheableMethods !== undefined) {
      this.cacheableMethods = options.cacheableMethods;
    }
    
    return this;
  },
  
  // Get cache statistics
  getStats() {
    const stats = {
      size: this.cache.size,
      hits: 0,
      expired: 0,
      active: 0
    };
    
    for (const entry of this.cache.values()) {
      stats.hits += entry.hits;
      
      if (this.isExpired(entry)) {
        stats.expired++;
      } else {
        stats.active++;
      }
    }
    
    return stats;
  }
});

/* ============================
   HTML Sanitizer Plugin
============================ */

/**
 * A plugin for sanitizing HTML content before insertion
 */
export const SanitizerPlugin = createPlugin({
  name: 'sanitizer',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 20,
  description: 'Sanitizes HTML content before insertion into the DOM',
  author: 'Team Fixi',
  
  // Custom sanitizer function
  sanitizerFn: null as ((html: string) => string) | null,
  
  // Only run for responses with a target
  conditions: {
    [PluginHook.AFTER_RESPONSE]: (context: RequestPluginContext) => {
      return !!(context.config.target && context.response?.text);
    }
  },
  
  // Initialize with optional custom sanitizer
  onInitialize(context) {
    // Default to null - will use basic sanitizer if none provided
  },
  
  // Sanitize HTML before it's inserted into the DOM
  afterResponse(context) {
    if (context.response && typeof context.response.text === 'string' && context.config.target) {
      context.response.text = this.sanitize(context.response.text);
    }
    
    return context.response!;
  },
  
  // Sanitize HTML content
  sanitize(html: string): string {
    if (this.sanitizerFn) {
      return this.sanitizerFn(html);
    }
    
    // Basic sanitization - for production use DOMPurify or similar
    return this.basicSanitize(html);
  },
  
  // Basic sanitization function
  basicSanitize(html: string): string {
    // Remove script tags and inline event handlers
    html = html
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/on\w+="[^"]*"/gi, '')
      .replace(/on\w+='[^']*'/gi, '')
      .replace(/on\w+=\w+/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi, '')
      .replace(/<embed\b[^<]*(?:(?!<\/embed>)<[^<]*)*<\/embed>/gi, '');
    
    return html;
  },
  
  // Set a custom sanitizer function
  setCustomSanitizer(fn: (html: string) => string) {
    this.sanitizerFn = fn;
    return this;
  }
});

/* ============================
   Error Handler Plugin
============================ */

/**
 * Error handler function type
 */
type ErrorHandler = (response: FxResponse, context: RequestPluginContext) => void | Promise<void>;

/**
 * A plugin for handling errors across the application
 */
export const ErrorHandlerPlugin = createPlugin({
  name: 'errorHandler',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 10,
  description: 'Provides global error handling for AJAX requests',
  author: 'Team Fixi',
  
  // Map of status codes to handlers
  statusHandlers: new Map<number, ErrorHandler>(),
  
  // Default error handler
  defaultHandler: null as ErrorHandler | null,
  
  // Retry configuration
  retryConfig: {
    enabled: false,
    maxRetries: 3,
    retryStatuses: [408, 429, 500, 502, 503, 504],
    backoff: (attempt: number) => Math.min(1000 * Math.pow(2, attempt), 30000)
  },
  
  // Only run for error responses
  conditions: {
    [PluginHook.AFTER_RESPONSE]: (context: RequestPluginContext) => {
      return !context.response?.ok;
    }
  },
  
  // Handle error responses
  afterResponse(context) {
    if (!context.response?.ok) {
      const status = context.response?.status || 0;
      
      // Check for automatic retry
      if (
        this.retryConfig.enabled &&
        context.config.__retryCount === undefined &&
        this.retryConfig.retryStatuses.includes(status)
      ) {
        return this.retryRequest(context);
      }
      
      // Find and execute appropriate handler
      if (this.statusHandlers.has(status)) {
        const handler = this.statusHandlers.get(status)!;
        handler(context.response!, context);
      } else if (this.defaultHandler) {
        this.defaultHandler(context.response!, context);
      }
    }
    
    return context.response!;
  },
  
  // Set a handler for a specific HTTP status code
  setStatusHandler(status: number, handler: ErrorHandler) {
    this.statusHandlers.set(status, handler);
    return this;
  },
  
  // Set the default error handler
  setDefaultHandler(handler: ErrorHandler) {
    this.defaultHandler = handler;
    return this;
  },
  
  // Remove a status handler
  removeStatusHandler(status: number) {
    this.statusHandlers.delete(status);
    return this;
  },
  
  // Configure retry behavior
  configureRetry(options: Partial<typeof this.retryConfig>) {
    this.retryConfig = { ...this.retryConfig, ...options };
    return this;
  },
  
  // Retry a failed request
  async retryRequest(context: RequestPluginContext): Promise<FxResponse> {
    const retryCount = context.config.__retryCount || 0;
    
    if (retryCount >= this.retryConfig.maxRetries) {
      return context.response!;
    }
    
    // Create a new config for retry
    const newConfig = { ...context.config };
    newConfig.__retryCount = retryCount + 1;
    
    // Calculate backoff delay
    const delay = typeof this.retryConfig.backoff === 'function'
      ? this.retryConfig.backoff(retryCount)
      : this.retryConfig.backoff;
    
    // Wait before retrying
    await new Promise(resolve => setTimeout(resolve, delay));
    
    // Retry the request
    try {
      const response = await context.fixi.fetch(newConfig);
      return response;
    } catch (error) {
      // If retry fails, return the original error response
      return context.response!;
    }
  }
});

/* ============================
   CSRF Token Plugin
============================ */

/**
 * A plugin for managing CSRF token refresh
 */
export const CsrfPlugin = createPlugin({
  name: 'csrf',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 80,
  description: 'Manages CSRF token refresh and inclusion in requests',
  author: 'Team Fixi',
  
  // CSRF token header name
  headerName: 'X-CSRF-Token',
  
  // Selector for the meta tag containing the CSRF token
  tokenSelector: 'meta[name="csrf-token"]',
  
  // Current token value
  token: '',
  
  // Initialize the plugin
  onInitialize(context) {
    this.refreshToken();
  },
  
  // Add the CSRF token to non-GET requests
  beforeRequest(context) {
    const method = context.config.method || 'GET';
    
    // Only add CSRF token for state-changing requests
    if (method !== 'GET' && method !== 'HEAD' && this.token) {
      // Initialize headers if not present
      context.config.headers = context.config.headers || {};
      
      // Add CSRF token header
      context.config.headers[this.headerName] = this.token;
    }
    
    return context.config;
  },
  
  // Handle 403 errors by refreshing token and retrying
  afterResponse(context) {
    // Check for CSRF token expiration (403 Forbidden)
    if (context.response?.status === 403) {
      const oldToken = this.token;
      this.refreshToken();
      
      // If token changed, retry the request
      if (oldToken !== this.token && context.config.method !== 'GET') {
        // Create a new config with updated token
        const newConfig = { ...context.config };
        newConfig.headers = newConfig.headers || {};
        newConfig.headers[this.headerName] = this.token;
        
        // Retry the request
        return context.fixi.fetch(newConfig);
      }
    }
    
    return context.response!;
  },
  
  // Refresh the CSRF token from the meta tag
  refreshToken() {
    if (typeof document !== 'undefined') {
      const meta = document.querySelector(this.tokenSelector);
      if (meta && meta.getAttribute('content')) {
        this.token = meta.getAttribute('content')!;
      }
    }
    return this.token;
  },
  
  // Set the token explicitly
  setToken(token: string) {
    this.token = token;
    return this;
  },
  
  // Configure the plugin
  configure(options: { headerName?: string; tokenSelector?: string }) {
    if (options.headerName) {
      this.headerName = options.headerName;
    }
    
    if (options.tokenSelector) {
      this.tokenSelector = options.tokenSelector;
    }
    
    this.refreshToken();
    return this;
  }
});

/* ============================
   Offline Support Plugin
============================ */

/**
 * Offline support configuration
 */
interface OfflineConfig {
  enabled: boolean;
  queueKey: string;
  syncOnReconnect: boolean;
}

/**
 * A plugin for handling offline operations
 */
export const OfflinePlugin = createPlugin({
  name: 'offline',
  version: '1.0.0',
  apiVersion: '2.0.0',
  priority: 95, // Very high priority to intercept before other plugins
  description: 'Provides offline support by queuing requests when offline',
  author: 'Team Fixi',
  
  // Offline configuration
  config: {
    enabled: true,
    queueKey: 'fixi_offline_queue',
    syncOnReconnect: true
  } as OfflineConfig,
  
  // Queue of pending requests
  queue: [] as Array<{
    config: any;
    timestamp: number;
  }>,
  
  // Online status
  isOnline: true,
  
  // Initialize the plugin
  onInitialize(context) {
    // Set initial online status
    this.isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;
    
    // Load queue from storage
    this.loadQueue();
    
    // Add event listeners for online/offline events
    if (typeof window !== 'undefined') {
      window.addEventListener('online', this.handleOnline.bind(this));
      window.addEventListener('offline', this.handleOffline.bind(this));
    }
  },
  
  // Clean up when unregistered
  onDestroy() {
    // Remove event listeners
    if (typeof window !== 'undefined') {
      window.removeEventListener('online', this.handleOnline.bind(this));
      window.removeEventListener('offline', this.handleOffline.bind(this));
    }
    
    // Save queue to storage
    this.saveQueue();
  },
  
  // Check if offline before making request
  beforeRequest(context) {
    if (!this.isOnline && this.config.enabled) {
      // Skip GET requests or requests with { offline: false }
      if (context.config.method === 'GET' || context.config.offline === false) {
        // Throw network error for consistency
        throw new Error('Network error: No internet connection');
      }
      
      // Queue the request for later
      this.queueRequest(context.config);
      
      // Create a fake response
      const fakeResponse = {
        ok: true,
        status: 202, // Accepted
        text: JSON.stringify({ queued: true, message: 'Request queued for when online' }),
        headers: new Headers({ 'Content-Type': 'application/json' }),
        url: