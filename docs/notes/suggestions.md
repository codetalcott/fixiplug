
The core plugin API (hooks.js) is an event bus with manual dispatch; each plugin registers handlers for named hooks and Fixi emits those hooks during lifecycle phases (init/config/before/after/etc.). That pattern is more akin to a publish/subscribe system than DOM event delegation—handlers run for every event emission regardless of element ancestry. Delegation exists only in the DOM bootstrap (fixi-dom.js) where each [fx-action] element receives its own listener rather than using a single ancestor listener.
Because every interactive node gets an independent event handler, large documents can accumulate many listeners. If you have dense UI trees, consider augmenting the DOM layer with optional delegation (e.g., register one listener on document for clicks/changes and route to the closest [fx-action]). That could live in a plugin so existing behavior stays backward compatible.
Hooks currently run in series and each handler can mutate the shared event object. For better robustness you could freeze snapshots before dispatching, pass copies to plugins, or add TypeScript types for hook payloads to avoid accidental mutation.
Error handling queues exceptions asynchronously but still logs to the console. Providing a configurable error hook (already pluginError) plus retries/backoff strategies would help plugins that need resilience.
Fixi.fetch exposes only success helpers (json, text) and the raw headers. You might let plugins intercept responses before .text() is called, or add streaming/body piping support for large payloads.
Skill metadata (Fixi.skillRegistry) is a map but lacks lifecycle hooks for updates/removals when plugins hot-reload. Exposing explicit APIs for capability discovery and versioning would make skills more practical.
If you want concrete improvements, I’d prototype a DOM-layer delegation plugin and add typed hook contracts so plugin authors have clearer guarantees.
